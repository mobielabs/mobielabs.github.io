---
title: Microservice Architecutre | jepil choi
description: Microservice Architecutre
header: Microservice Architecutre
---
# 시작
>"마이크로 서비스(Microservice)"는 소프트웨어 아키텍처에 있어서 아직은 새로운 용어다. 일반적으로 이런 것들은 얕잡아 보게 되고 무시되는 경향이 있기는 하지만, 이 짧은 용어는 점점 더 설득력 있게 보이는 소프트웨어 시스템들의 스타일을 설명한다. 우리는 지난 몇 년 동안 이런 스타일이 적용된 수많은 프로젝트들을 보아왔다. 결과는 지금까지 긍정적이었다. 이런 긍정적인 결과들로 인해 이 스타일은 점점 우리 동료들의 기본적인 기업 애플리케이션 개발 스타일이 되어가고 있다. 그러나 불행히도 아직까지 마이크로 서비스 스타일이 무엇인지, 어떻게 적용하는지에 대해 대강이라도 설명하는 정보들은 부족하다.

## Monolithic architecture

## Monolithic architecture가 발전 되었을 때의 문제점
1. 어플리케이션 배포에 한시간 이상 소요
2. 서비스 복잡도가 증가하여 단순 기능 수정에도 전체 QA가 필요
3. 단순 버그 수정이 더 중대한 버그를 생산하는 일이 빈번
4. 부분적 스케일 아웃의 어려움
5. 안정성의 감소

# 마이크로서비스 아키텍쳐란?
- 하나의 큰 어플리케이션을 여러개의 독립적인 역할을 수행하는 작은 어플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍쳐.
- '인증'을 담당하는 서비스, '사용자 관리', '주문 관리', '결제 관리', '알림 관리', '검색'을 담당하는 서비스등을 추상화 시켜 인터페이스로 연결.
- REST API의 일반화, 컨테이너 기술(Docker등), 클라우드 컴퓨팅의 발전이 가속화 시키고 있음.
- 비즈니스 개발, 배포 자동화, 지능적인 엔드포인트, 중립적인 언어나 데이터, 비 집중화된 제어 등의 공통적인 특징

## 마이크로서비스 아키텍쳐의 DB 설계
- 서비스 별로 별도의 데이터베이스를 사용하여 장점을 극대화.
- 트랜잭션 관리나 정규화 관점에서 비효율적.
- RDBMS와 NoSQL, Bigdata등을 용도에 맞춰서 각 서비스별로 섞어 사용.

## Why?
- 세상은 단순한 법칙으로 복잡하게 구조화되어 있다.
- 작은 팀으로 큰 것을 만든다.
- 7명 = 21, 8명 = 28, 9명 = 36, 10명 = 45
- 이미 7명과 10명은 두배...
- 뭔가 말랑말랑한 구조를 가져가야 그때그때 새로 만들 수 있다.

## 장점
- 개별적인 독립 어플리케이션이기 때문에 변경이 용이
- 변경이 미치는 영향이 적음
- 개별 서비스 단위 배포가 가능
- 부하가 집중되는 서비스만 스케일 아웃
- 서비스 특징에 맞춰서 자원 할당(CPU, Memory등)
- 독립적인 서비스별로 개발과 배포가 가능해져 조직의 프로세스 단순화와 품질 증가

## 단점
- 서비스간 통신에 대한 처리가 추가됨
- 분산된 데이터 베이스의 트랜젝션 처리가 어려움(정합성 유지)
- 많은 서비스를 배포, 관리 해야함(운영)

## 문제점→ 해결책
- 설계의 어려움 → Domain Driven Design
- 레거시 시스템과의 공존, 인터페이스 연계 → API Gateway
- 운영 오버헤드 → DevOps/NoOps
- 코드중복 → 허용
- 분산시스템의 복잡성과 비동기성 → Actor model
- 테스트 → API Gateway / Log system

## API Gateway
- 클라이언트가 각각의 마이크로서비스들을 모두 호출하여 취합하는 경우 속도문제 뿐 아니라 서비스가 추가되거나 호스트가 변경되면 클라이언트 또한 변경 필요 또한 마이크로서비스를 클라이언트가 직접 호출하도록 하는 방식은 보안에 더욱 많이 신경써야하며 클라이어트 코드가 많고 복잡해짐
- 이를 해결하기 위하여 API Gateway를 사용
- 클라이언트의 요청을 각 마이크로서비스에 요청하고 취합하여 전달, 이때 프로토콜 변환등이 일어나기도 함
- 부하분산, 캐싱, 모니터링을 동시에 수행
- Gateway 내부를 캡슐화 시켜 서비스의 변경, 분리, 추가등이 클라이언트와 별개로 이루어짐
- 보통 비동기적이고 non-blocking IO 처리가 가능하도록 구현
- 서비스의 선후관계 처리 시 콜백 지옥을 피하기 위해 JS의 promise등을 이용한 Reactive  프로그래밍을 도입
- 특정 서비스에 문제가 발생 했을 시 각  케이스별로 대응 가능한 예외처리가 구현되어야함
- 중복이 되더라도 필요한 API를 각각의 팀이 따로 만든다
- 데이타가 같으니 일관성은 보장이 될터이고, 각 팀으로 서비스를 나눠서 각팀이 각각의 API를 만들게 되면, 기동성이 늘어나고, 고객의 요구 사항이 각각 다르니 거기에 기민하게 대응할 수 있다

## 무엇을 만들어야 하는가?
- 새로운 기술과 언어를 기존의 서비스에 쉽게 적용할 수 있도록 한다.
- 누구라도 빠르게 개발에 참여 할 수 있도록 한다.
- 쉽게 이해 할 수 있어야 한다.
- 쉽게 수정될 수 있어야 한다.
- 폴리글랏으로 개발 될 수 있어야 한다.
- 부분적인 확장으로 성능의 개선이 이루어 질 수 있어야 한다.
- 머신의 물리적인 에러가 전체적인 어플리케이션의 동작에 영향을 주지 않아야 한다.
- 단순하게 복사만으로 deploy 될 수 있어야 한다.
- 발견된 에러는 자동으로 보고되고 처리되어야 한다.
- 어떻게 구현 할 수 있을까?
- 아키텍쳐는 완성된 것이 아니라 현재 가장 적합한 것일 뿐이다.
- 나중에는 당연히 바꿔야 한다.
- 복잡함은 자동화로 커버한다.
- 변화의 위험을 툴과 문화로 줄인다.
- 비지니스 기능을 중심으로 나노서비스들을 결합시켜 나간다.
- Actor model
- Domain Driven Design
- Event driven architecture
- API First (REST API Maturity Lv2 이상)
